#!/usr/bin/ruby -w

#  miniArp.c by Matthias Nagorni
# See http://www.suse.de/~mana/miniArp.c

TICKS_PER_QUARTER = 128

require 'rrts/rrts'

include RRTS
include Driver

# Germans call b h
Map1 = {'c'=>0, 'd'=>2, 'e'=>4, 'f'=>5, 'g'=>7, 'a'=>9, 'b'=>11, 'h'=>11,
        'C'=>0, 'D'=>2, 'E'=>4, 'F'=>5, 'G'=>7, 'A'=>9, 'B'=>11, 'H'=>11
        }

class ArpeggioNote
  private
  def initialize note, duration, delta
    @note, @duration, @delta = note, duration, delta
  end
  public

  attr :note, :duration, :delta
end

def parse_sequence filename

#   FILE *f;
# char c;
  sequence = []
#   sequence[0] = sequence[1] = sequence[2] = []  #BEGINNER MISTAKE
  File::open(filename, "r") do |file|
    chars = file.chars
    loop do
      c = chars.next
#       puts "#{File.basename(__FILE__)}:#{__LINE__}:read '#{c}'"
      break if c == "\n"
      note = Map1[c] or fail("Bad note '#{c}'")
      c =  chars.next
      if c == '#'
        note += 1
        c = chars.next
      end
#       puts "read '#{c}'"
      note += 12 * c.to_i
      c = chars.next
#       puts "read '#{c}'"
      duration = TICKS_PER_QUARTER / c.to_i
      c = chars.next
#       puts "read '#{c}'"
      delta = TICKS_PER_QUARTER / c.to_i
      sequence << ArpeggioNote.new(note, duration, delta)
#       puts "seq_len now is #@seq_len"
    end
  end
#   puts "sequence is now #{sequence.inspect}"
  sequence
end

def arpeggio
  for arpnote, l1 in @sequence.each_with_index
    dt = (l1 % 2 == 0) ? @swing.to_f / 16384.0 : @swing.to_f / 16384.0
    ev = ev_malloc
    ev.clear
#     puts "sequence=#{@sequence.inspect}"
    # we use note and note noteon here!
    note = arpnote.note + @transpose
    duration = arpnote.duration
#     puts "note #{note}, duratiodn #{duration}, l1=#{l1}, transpose=#@transpose"
    ev.set_note 0, note, 127, duration
    ev.schedule_tick @queue, 0, @tick
    ev.source = @port_out
    ev.set_subs
    @sequencer.event_output_direct ev
    @tick += (arpnote.delta.to_f * (1.0 + dt)).to_i
  end
  ev.clear
  ev.type = SND_SEQ_EVENT_ECHO
  ev.schedule_tick @queue,  0, @tick
  ev.dest = @port_in
  @sequencer.event_output_direct ev
end

def get_tick
  @queue.status.tick_time
end

def clear_queue
  @queue.clear
#   remove_ev = remove_events_malloc
#   remove_ev.queue = @queue
#   remove_ev.condition = SND_SEQ_REMOVE_OUTPUT | SND_SEQ_REMOVE_IGNORE_OFF
#   @sequencer.remove_events(remove_ev) if @sequencer   # racecondition?? Who makes it nil anyway?
end

# also called when modwheel is used.
def set_tempo
#   queue_tempo = queue_tempo_malloc
#   tempo = 60_000_000 / (@bpm * TICKS_PER_QUARTER) * TICKS_PER_QUARTER
#   queue_tempo.tempo = tempo
#   queue_tempo.ppq = TICKS_PER_QUARTER
  @queue.tempo = { bpm: @bpm, ticks_per_quarter: TICKS_PER_QUARTER }
end

def midi_action
  loop do
    (ev, remains = @sequencer.event_input) or break
    case ev
    when EchoEvent then arpeggio
    when NoteOnEvent
      clear_queue
      @transpose = ev.note - 60
      @tick = get_tick
      arpeggio
    when ControllerEvent
      if ev.param == MIDI_CTL_MSB_MODWHEEL # 1
        @bpm = (@bpm0.to_f * (1.0 + ev.value.to_f / 127.0)).to_i
        set_tempo
      end
    when PitchbendEvent
      @swing = ev.value.to_f
    end
    return if remains == 0 # @sequencer.event_input_pending(false) == 0
  end
end

def sigterm_exit
  STDERR.print("Closing, please wait...");
  clear_queue
  sleep 2
  STDERR.puts
  # note that this calls the ensure in Sequencer, so everything is properly cleared.
  exit
end

# int main(int argc, char *argv[]) {

#   int npfd, l1;
# struct pollfd *pfd;

if ARGV.length < 2
  fail "\nUsage:\nminiarp.rb <beats per minute> <sequence file>\n"
end
@bpm0 = Integer(ARGV[0])
@bpm = @bpm0
@swing = @transpose = @tick = 0
@sequence = parse_sequence ARGV[1]
require 'rrts/sequencer'
Sequencer.new 'miniArp' do |seq|
  @sequencer = seq
  @port_out = MidiPort.new(seq, "miniArp O", read: true, subs_read: true, application: true)
  @port_in = MidiPort.new(seq, 'miniArp I', write: true, subs_write: true, application: true)
  @queue = @sequencer.create_queue 'miniArp'
  @sequencer.client_pool_output = (@sequence.length << 1) + 4
  set_tempo
  arpeggio
  @queue.start
  @sequencer.flush
  descriptors = seq.poll_descriptors(Sequencer::PollIn)
  @transpose = @swing = @tick = 0
  Signal.trap(:INT) {  sigterm_exit }
  Signal.trap(:TERM) { sigterm_exit }
  arpeggio
  loop do
    midi_action if descriptors.poll(100_000)
  end
end